<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xxHash: XXH3 family</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">xxHash<span id="projectnumber">&#160;0.8.2</span>
   </div>
   <div id="projectbrief">Extremely fast non-cryptographic hash function</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">XXH3 family<div class="ingroups"><a class="el" href="group__public.html">Public API</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return value from 128-bit hashes.  <a href="struct_x_x_h128__hash__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_x_h128__canonical__t.html">XXH128_canonical_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaeb79a9111c58af32599f8e5cd71d67d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#gaeb79a9111c58af32599f8e5cd71d67d2">XXH3_SECRET_SIZE_MIN</a>&#160;&#160;&#160;136</td></tr>
<tr class="separator:gaeb79a9111c58af32599f8e5cd71d67d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8e454084a62efb09fad8ba3cc1c1b1d0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_x_x_h3__state__s.html">XXH3_state_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a></td></tr>
<tr class="memdesc:ga8e454084a62efb09fad8ba3cc1c1b1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state struct for the XXH3 streaming API.  <br /></td></tr>
<tr class="separator:ga8e454084a62efb09fad8ba3cc1c1b1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0c06e71549705effd58cb7bd0969307e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga0c06e71549705effd58cb7bd0969307e">XXH3_64bits</a> (XXH_NOESCAPE const void *input, size_t length)</td></tr>
<tr class="memdesc:ga0c06e71549705effd58cb7bd0969307e"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit unseeded variant of XXH3.  <br /></td></tr>
<tr class="separator:ga0c06e71549705effd58cb7bd0969307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b51002ff2a438e38c1ee45abcd09659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga4b51002ff2a438e38c1ee45abcd09659">XXH3_64bits_withSeed</a> (XXH_NOESCAPE const void *input, size_t length, <a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> seed)</td></tr>
<tr class="memdesc:ga4b51002ff2a438e38c1ee45abcd09659"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit seeded variant of XXH3  <br /></td></tr>
<tr class="separator:ga4b51002ff2a438e38c1ee45abcd09659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga870ba5470efb3befb1a70cb35dae12cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga870ba5470efb3befb1a70cb35dae12cd">XXH3_64bits_withSecret</a> (XXH_NOESCAPE const void *data, size_t len, XXH_NOESCAPE const void *secret, size_t secretSize)</td></tr>
<tr class="memdesc:ga870ba5470efb3befb1a70cb35dae12cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit variant of XXH3 with a custom "secret".  <br /></td></tr>
<tr class="separator:ga870ba5470efb3befb1a70cb35dae12cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95592969a08becc37428dd547c36b8fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga95592969a08becc37428dd547c36b8fd">XXH3_createState</a> (void)</td></tr>
<tr class="memdesc:ga95592969a08becc37428dd547c36b8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>.  <br /></td></tr>
<tr class="separator:ga95592969a08becc37428dd547c36b8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee640ba2104fe3107b7d679f40d17277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#gaee640ba2104fe3107b7d679f40d17277">XXH3_freeState</a> (<a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr)</td></tr>
<tr class="memdesc:gaee640ba2104fe3107b7d679f40d17277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>.  <br /></td></tr>
<tr class="separator:gaee640ba2104fe3107b7d679f40d17277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f6f3b90b0b88415927dfe3e045b35e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga77f6f3b90b0b88415927dfe3e045b35e">XXH3_copyState</a> (XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *dst_state, XXH_NOESCAPE const <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *src_state)</td></tr>
<tr class="memdesc:ga77f6f3b90b0b88415927dfe3e045b35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies one <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> to another.  <br /></td></tr>
<tr class="separator:ga77f6f3b90b0b88415927dfe3e045b35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab540c4db302e1845b6061d1572bcd76e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#gab540c4db302e1845b6061d1572bcd76e">XXH3_64bits_reset</a> (XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr)</td></tr>
<tr class="memdesc:gab540c4db302e1845b6061d1572bcd76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> to begin a new hash.  <br /></td></tr>
<tr class="separator:gab540c4db302e1845b6061d1572bcd76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7e751b1131fccff2be34624ff770591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#gaa7e751b1131fccff2be34624ff770591">XXH3_64bits_reset_withSeed</a> (XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr, <a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> seed)</td></tr>
<tr class="memdesc:gaa7e751b1131fccff2be34624ff770591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> with 64-bit seed to begin a new hash.  <br /></td></tr>
<tr class="separator:gaa7e751b1131fccff2be34624ff770591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ebc78d44e7767aa2779571bd118a126"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga0ebc78d44e7767aa2779571bd118a126">XXH3_64bits_reset_withSecret</a> (XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr, XXH_NOESCAPE const void *secret, size_t secretSize)</td></tr>
<tr class="separator:ga0ebc78d44e7767aa2779571bd118a126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacca0e39d67b023700ade8b0eca4e0a13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#gacca0e39d67b023700ade8b0eca4e0a13">XXH3_64bits_update</a> (XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr, XXH_NOESCAPE const void *input, size_t length)</td></tr>
<tr class="memdesc:gacca0e39d67b023700ade8b0eca4e0a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes a block of <code>input</code> to an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>.  <br /></td></tr>
<tr class="separator:gacca0e39d67b023700ade8b0eca4e0a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd6a50b808c5fc47f91ed3f5b85fcfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga8fd6a50b808c5fc47f91ed3f5b85fcfc">XXH3_64bits_digest</a> (XXH_NOESCAPE const <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr)</td></tr>
<tr class="memdesc:ga8fd6a50b808c5fc47f91ed3f5b85fcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the calculated XXH3 64-bit hash value from an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>.  <br /></td></tr>
<tr class="separator:ga8fd6a50b808c5fc47f91ed3f5b85fcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8051df2b6621c36b542ae1b5df2dd2f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga8051df2b6621c36b542ae1b5df2dd2f9">XXH3_128bits</a> (XXH_NOESCAPE const void *data, size_t len)</td></tr>
<tr class="memdesc:ga8051df2b6621c36b542ae1b5df2dd2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unseeded 128-bit variant of XXH3.  <br /></td></tr>
<tr class="separator:ga8051df2b6621c36b542ae1b5df2dd2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c66790514ddccf7ac33e4ed1b1ad5e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga2c66790514ddccf7ac33e4ed1b1ad5e7">XXH3_128bits_withSeed</a> (XXH_NOESCAPE const void *data, size_t len, <a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> seed)</td></tr>
<tr class="memdesc:ga2c66790514ddccf7ac33e4ed1b1ad5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeded 128-bit variant of XXH3.  <br /></td></tr>
<tr class="separator:ga2c66790514ddccf7ac33e4ed1b1ad5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192ce854fdff8d491ec5201268007401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga192ce854fdff8d491ec5201268007401">XXH3_128bits_withSecret</a> (XXH_NOESCAPE const void *data, size_t len, XXH_NOESCAPE const void *secret, size_t secretSize)</td></tr>
<tr class="memdesc:ga192ce854fdff8d491ec5201268007401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom secret 128-bit variant of XXH3.  <br /></td></tr>
<tr class="separator:ga192ce854fdff8d491ec5201268007401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4fef3307630a356a65eaf1589db53c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#gaf4fef3307630a356a65eaf1589db53c0">XXH3_128bits_reset</a> (XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr)</td></tr>
<tr class="memdesc:gaf4fef3307630a356a65eaf1589db53c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> to begin a new hash.  <br /></td></tr>
<tr class="separator:gaf4fef3307630a356a65eaf1589db53c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e225fe11a64c6a3a4a95668d8389794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga7e225fe11a64c6a3a4a95668d8389794">XXH3_128bits_reset_withSeed</a> (XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr, <a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> seed)</td></tr>
<tr class="memdesc:ga7e225fe11a64c6a3a4a95668d8389794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> with 64-bit seed to begin a new hash.  <br /></td></tr>
<tr class="separator:ga7e225fe11a64c6a3a4a95668d8389794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16f78f1d03c546e274ee18fe32ed2f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga16f78f1d03c546e274ee18fe32ed2f6b">XXH3_128bits_reset_withSecret</a> (XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr, XXH_NOESCAPE const void *secret, size_t secretSize)</td></tr>
<tr class="memdesc:ga16f78f1d03c546e274ee18fe32ed2f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom secret 128-bit variant of XXH3.  <br /></td></tr>
<tr class="separator:ga16f78f1d03c546e274ee18fe32ed2f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08cea3acdfdc9bc7102c4ae133ef702a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga08cea3acdfdc9bc7102c4ae133ef702a">XXH3_128bits_update</a> (XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr, XXH_NOESCAPE const void *input, size_t length)</td></tr>
<tr class="memdesc:ga08cea3acdfdc9bc7102c4ae133ef702a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes a block of <code>input</code> to an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>.  <br /></td></tr>
<tr class="separator:ga08cea3acdfdc9bc7102c4ae133ef702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1239aeb6d2b2604f8d227ff5546473f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga1239aeb6d2b2604f8d227ff5546473f8">XXH3_128bits_digest</a> (XXH_NOESCAPE const <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr)</td></tr>
<tr class="memdesc:ga1239aeb6d2b2604f8d227ff5546473f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the calculated XXH3 128-bit hash value from an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>.  <br /></td></tr>
<tr class="separator:ga1239aeb6d2b2604f8d227ff5546473f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae48a69e41062619715826660580d42ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#gae48a69e41062619715826660580d42ab">XXH128_isEqual</a> (<a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> h1, <a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> h2)</td></tr>
<tr class="separator:gae48a69e41062619715826660580d42ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f31fe3cef649f8b78fca6e5040f9b74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga6f31fe3cef649f8b78fca6e5040f9b74">XXH128_cmp</a> (XXH_NOESCAPE const void *h128_1, XXH_NOESCAPE const void *h128_2)</td></tr>
<tr class="memdesc:ga6f31fe3cef649f8b78fca6e5040f9b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> This comparator is compatible with stdlib's <code>qsort()</code>/<code>bsearch()</code>.  <br /></td></tr>
<tr class="separator:ga6f31fe3cef649f8b78fca6e5040f9b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a6b47e068251634e4984117eae520a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga04a6b47e068251634e4984117eae520a">XXH128_canonicalFromHash</a> (XXH_NOESCAPE <a class="el" href="struct_x_x_h128__canonical__t.html">XXH128_canonical_t</a> *dst, <a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> hash)</td></tr>
<tr class="memdesc:ga04a6b47e068251634e4984117eae520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> to a big endian <a class="el" href="struct_x_x_h128__canonical__t.html">XXH128_canonical_t</a>.  <br /></td></tr>
<tr class="separator:ga04a6b47e068251634e4984117eae520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe959cfcddb1dad57a532eb57d22661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga9fe959cfcddb1dad57a532eb57d22661">XXH128_hashFromCanonical</a> (XXH_NOESCAPE const <a class="el" href="struct_x_x_h128__canonical__t.html">XXH128_canonical_t</a> *src)</td></tr>
<tr class="memdesc:ga9fe959cfcddb1dad57a532eb57d22661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="struct_x_x_h128__canonical__t.html">XXH128_canonical_t</a> to a native <a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>.  <br /></td></tr>
<tr class="separator:ga9fe959cfcddb1dad57a532eb57d22661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2680c1ef72d4deab6fe8e00b7eb83ee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga2680c1ef72d4deab6fe8e00b7eb83ee5">XXH3_64bits_reset_withSecretandSeed</a> (XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr, XXH_NOESCAPE const void *secret, size_t secretSize, <a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> seed64)</td></tr>
<tr class="separator:ga2680c1ef72d4deab6fe8e00b7eb83ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c198e9d131046515c7d6a2d65d099b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga7c198e9d131046515c7d6a2d65d099b7">XXH3_128bits_withSecretandSeed</a> (XXH_NOESCAPE const void *input, size_t length, XXH_NOESCAPE const void *secret, size_t secretSize, <a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> seed64)</td></tr>
<tr class="separator:ga7c198e9d131046515c7d6a2d65d099b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7090a47ff2c03b7da2082d776610aa95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga7090a47ff2c03b7da2082d776610aa95">XXH128</a> (XXH_NOESCAPE const void *data, size_t len, <a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> seed)</td></tr>
<tr class="separator:ga7090a47ff2c03b7da2082d776610aa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57580a70118de171d0236b415d488b3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga57580a70118de171d0236b415d488b3e">XXH3_128bits_reset_withSecretandSeed</a> (XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *statePtr, XXH_NOESCAPE const void *secret, size_t secretSize, <a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> seed64)</td></tr>
<tr class="separator:ga57580a70118de171d0236b415d488b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a3a4fbe45ae0863652178fa00465b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#ga88a3a4fbe45ae0863652178fa00465b3">XXH3_generateSecret</a> (XXH_NOESCAPE void *secretBuffer, size_t secretSize, XXH_NOESCAPE const void *customSeed, size_t customSeedSize)</td></tr>
<tr class="separator:ga88a3a4fbe45ae0863652178fa00465b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa895f02acfc127b1d34d0d558a6773b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_x_h3__family.html#gaa895f02acfc127b1d34d0d558a6773b0">XXH3_generateSecret_fromSeed</a> (XXH_NOESCAPE void *secretBuffer, <a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> seed)</td></tr>
<tr class="memdesc:gaa895f02acfc127b1d34d0d558a6773b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the same secret as the _withSeed() variants.  <br /></td></tr>
<tr class="separator:gaa895f02acfc127b1d34d0d558a6773b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<hr  />
<p>XXH3 is a more recent hash algorithm featuring:</p><ul>
<li>Improved speed for both small and large inputs</li>
<li>True 64-bit and 128-bit outputs</li>
<li>SIMD acceleration</li>
<li>Improved 32-bit viability</li>
</ul>
<p>Speed analysis methodology is explained here:</p>
<p><a href="https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html">https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html</a></p>
<p>Compared to XXH64, expect XXH3 to run approximately ~2x faster on large inputs and &gt;3x faster on small ones, exact differences vary depending on platform.</p>
<p>XXH3's speed benefits greatly from SIMD and 64-bit arithmetic, but does not require it. Most 32-bit and 64-bit targets that can run XXH32 smoothly can run XXH3 at competitive speeds, even without vector support. Further details are explained in the implementation.</p>
<p>XXH3 has a fast scalar implementation, but it also includes accelerated SIMD implementations for many common platforms:</p><ul>
<li>AVX512</li>
<li>AVX2</li>
<li>SSE2</li>
<li>ARM NEON</li>
<li>WebAssembly SIMD128</li>
<li>POWER8 VSX</li>
<li>s390x ZVector This can be controlled via the <a class="el" href="group__tuning.html#gab216d0cd3d35dcfd7c6860ea296cdd86">XXH_VECTOR</a> macro, but it automatically selects the best version according to predefined macros. For the x86 family, an automatic runtime dispatcher is included separately in <a class="el" href="xxh__x86dispatch_8c.html">xxh_x86dispatch.c</a>.</li>
</ul>
<p>XXH3 implementation is portable: it has a generic C90 formulation that can be compiled on any platform, all implementations generate exactly the same hash value on all platforms. Starting from v0.8.0, it's also labelled "stable", meaning that any future version will also generate the same hash value.</p>
<p>XXH3 offers 2 variants, _64bits and _128bits.</p>
<p>When only 64 bits are needed, prefer invoking the _64bits variant, as it reduces the amount of mixing, resulting in faster speed on small inputs. It's also generally simpler to manipulate a scalar return type than a struct.</p>
<p>The API supports one-shot hashing, streaming mode, and custom secrets. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaeb79a9111c58af32599f8e5cd71d67d2" name="gaeb79a9111c58af32599f8e5cd71d67d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb79a9111c58af32599f8e5cd71d67d2">&#9670;&#160;</a></span>XXH3_SECRET_SIZE_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH3_SECRET_SIZE_MIN&#160;&#160;&#160;136</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The bare minimum size for a custom secret.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___x_x_h3__family.html#ga870ba5470efb3befb1a70cb35dae12cd" title="64-bit variant of XXH3 with a custom &quot;secret&quot;.">XXH3_64bits_withSecret()</a>, <a class="el" href="group___x_x_h3__family.html#ga0ebc78d44e7767aa2779571bd118a126">XXH3_64bits_reset_withSecret()</a>, <a class="el" href="group___x_x_h3__family.html#ga192ce854fdff8d491ec5201268007401" title="Custom secret 128-bit variant of XXH3.">XXH3_128bits_withSecret()</a>, <a class="el" href="group___x_x_h3__family.html#ga16f78f1d03c546e274ee18fe32ed2f6b" title="Custom secret 128-bit variant of XXH3.">XXH3_128bits_reset_withSecret()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8e454084a62efb09fad8ba3cc1c1b1d0" name="ga8e454084a62efb09fad8ba3cc1c1b1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e454084a62efb09fad8ba3cc1c1b1d0">&#9670;&#160;</a></span>XXH3_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_x_x_h3__state__s.html">XXH3_state_s</a> <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The state struct for the XXH3 streaming API. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_x_x_h3__state__s.html">XXH3_state_s</a> for details. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0c06e71549705effd58cb7bd0969307e" name="ga0c06e71549705effd58cb7bd0969307e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c06e71549705effd58cb7bd0969307e">&#9670;&#160;</a></span>XXH3_64bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> XXH3_64bits </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64-bit unseeded variant of XXH3. </p>
<p>This is equivalent to <a class="el" href="group___x_x_h3__family.html#ga4b51002ff2a438e38c1ee45abcd09659">XXH3_64bits_withSeed()</a> with a seed of 0, however it may have slightly better performance due to constant propagation of the defaults.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___x_x_h32__family.html#ga310c01be2371883ad3bb37930626ec86" title="Calculates the 32-bit hash of input using xxHash32.">XXH32()</a>, <a class="el" href="group___x_x_h64__family.html#ga089c4003cb11acb60d3d1b439c69e336" title="Calculates the 64-bit hash of input using xxHash64.">XXH64()</a>, <a class="el" href="group___x_x_h3__family.html#ga8051df2b6621c36b542ae1b5df2dd2f9" title="Unseeded 128-bit variant of XXH3.">XXH3_128bits()</a>: equivalent for the other xxHash algorithms </dd>
<dd>
<a class="el" href="group___x_x_h3__family.html#ga4b51002ff2a438e38c1ee45abcd09659" title="64-bit seeded variant of XXH3">XXH3_64bits_withSeed()</a>, <a class="el" href="group___x_x_h3__family.html#ga870ba5470efb3befb1a70cb35dae12cd" title="64-bit variant of XXH3 with a custom &quot;secret&quot;.">XXH3_64bits_withSecret()</a>: other seeding variants </dd>
<dd>
<a class="el" href="group___x_x_h3__family.html#gab540c4db302e1845b6061d1572bcd76e" title="Resets an XXH3_state_t to begin a new hash.">XXH3_64bits_reset()</a>, <a class="el" href="group___x_x_h3__family.html#gacca0e39d67b023700ade8b0eca4e0a13" title="Consumes a block of input to an XXH3_state_t.">XXH3_64bits_update()</a>, <a class="el" href="group___x_x_h3__family.html#ga8fd6a50b808c5fc47f91ed3f5b85fcfc" title="Returns the calculated XXH3 64-bit hash value from an XXH3_state_t.">XXH3_64bits_digest()</a>: Streaming version. </dd></dl>

</div>
</div>
<a id="ga4b51002ff2a438e38c1ee45abcd09659" name="ga4b51002ff2a438e38c1ee45abcd09659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b51002ff2a438e38c1ee45abcd09659">&#9670;&#160;</a></span>XXH3_64bits_withSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> XXH3_64bits_withSeed </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64-bit seeded variant of XXH3 </p>
<p>This variant generates a custom secret on the fly based on default secret altered using the <code>seed</code> value.</p>
<p>While this operation is decently fast, note that it's not completely free.</p>
<dl class="section note"><dt>Note</dt><dd>seed == 0 produces the same results as <a class="el" href="group___x_x_h3__family.html#ga0c06e71549705effd58cb7bd0969307e">XXH3_64bits()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The data to hash </td></tr>
    <tr><td class="paramname">length</td><td>The length </td></tr>
    <tr><td class="paramname">seed</td><td>The 64-bit seed to alter the state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga870ba5470efb3befb1a70cb35dae12cd" name="ga870ba5470efb3befb1a70cb35dae12cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga870ba5470efb3befb1a70cb35dae12cd">&#9670;&#160;</a></span>XXH3_64bits_withSecret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> XXH3_64bits_withSecret </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>secret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>secretSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64-bit variant of XXH3 with a custom "secret". </p>
<p>It's possible to provide any blob of bytes as a "secret" to generate the hash. This makes it more difficult for an external actor to prepare an intentional collision. The main condition is that secretSize <em>must</em> be large enough (&gt;= XXH3_SECRET_SIZE_MIN). However, the quality of the secret impacts the dispersion of the hash algorithm. Therefore, the secret <em>must</em> look like a bunch of random bytes. Avoid "trivial" or structured data such as repeated sequences or a text document. Whenever in doubt about the "randomness" of the blob of bytes, consider employing "XXH3_generateSecret()" instead (see below). It will generate a proper high entropy secret derived from the blob of bytes. Another advantage of using <a class="el" href="group___x_x_h3__family.html#ga88a3a4fbe45ae0863652178fa00465b3">XXH3_generateSecret()</a> is that it guarantees that all bits within the initial blob of bytes will impact every bit of the output. This is not necessarily the case when using the blob of bytes directly because, when hashing <em>small</em> inputs, only a portion of the secret is employed. </p>

</div>
</div>
<a id="ga95592969a08becc37428dd547c36b8fd" name="ga95592969a08becc37428dd547c36b8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95592969a08becc37428dd547c36b8fd">&#9670;&#160;</a></span>XXH3_createState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> * XXH3_createState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>. </p>
<p>Must be freed with <a class="el" href="group___x_x_h3__family.html#gaee640ba2104fe3107b7d679f40d17277" title="Frees an XXH3_state_t.">XXH3_freeState()</a>. </p><dl class="section return"><dt>Returns</dt><dd>An allocated XXH3_state_t on success, <code>NULL</code> on failure. </dd></dl>

</div>
</div>
<a id="gaee640ba2104fe3107b7d679f40d17277" name="gaee640ba2104fe3107b7d679f40d17277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee640ba2104fe3107b7d679f40d17277">&#9670;&#160;</a></span>XXH3_freeState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_freeState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>. </p>
<p>Must be allocated with <a class="el" href="group___x_x_h3__family.html#ga95592969a08becc37428dd547c36b8fd" title="Allocate an XXH3_state_t.">XXH3_createState()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statePtr</td><td>A pointer to an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> allocated with <a class="el" href="group___x_x_h3__family.html#ga95592969a08becc37428dd547c36b8fd">XXH3_createState()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XXH_OK. </dd></dl>

</div>
</div>
<a id="ga77f6f3b90b0b88415927dfe3e045b35e" name="ga77f6f3b90b0b88415927dfe3e045b35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f6f3b90b0b88415927dfe3e045b35e">&#9670;&#160;</a></span>XXH3_copyState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XXH3_copyState </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>dst_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>src_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies one <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_state</td><td>The state to copy to. </td></tr>
    <tr><td class="paramname">src_state</td><td>The state to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>dst_state</code> and <code>src_state</code> must not be <code>NULL</code> and must not overlap. </dd></dl>

</div>
</div>
<a id="gab540c4db302e1845b6061d1572bcd76e" name="gab540c4db302e1845b6061d1572bcd76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab540c4db302e1845b6061d1572bcd76e">&#9670;&#160;</a></span>XXH3_64bits_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_64bits_reset </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> to begin a new hash. </p>
<p>This function resets <code>statePtr</code> and generate a secret with default parameters. Call it before <a class="el" href="group___x_x_h3__family.html#gacca0e39d67b023700ade8b0eca4e0a13">XXH3_64bits_update()</a>. Digest will be equivalent to <code><a class="el" href="group___x_x_h3__family.html#ga0c06e71549705effd58cb7bd0969307e" title="64-bit unseeded variant of XXH3.">XXH3_64bits()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statePtr</td><td>The state struct to reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>statePtr</code> must not be <code>NULL</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534abd20b092d624344e301b0cadd29d5bd6">XXH_OK</a> on success, <a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534a462a18276729783125c7116cf102667f">XXH_ERROR</a> on failure. </dd></dl>

</div>
</div>
<a id="gaa7e751b1131fccff2be34624ff770591" name="gaa7e751b1131fccff2be34624ff770591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7e751b1131fccff2be34624ff770591">&#9670;&#160;</a></span>XXH3_64bits_reset_withSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_64bits_reset_withSeed </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> with 64-bit seed to begin a new hash. </p>
<p>This function resets <code>statePtr</code> and generate a secret from <code>seed</code>. Call it before <a class="el" href="group___x_x_h3__family.html#gacca0e39d67b023700ade8b0eca4e0a13">XXH3_64bits_update()</a>. Digest will be equivalent to <code><a class="el" href="group___x_x_h3__family.html#ga4b51002ff2a438e38c1ee45abcd09659" title="64-bit seeded variant of XXH3">XXH3_64bits_withSeed()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statePtr</td><td>The state struct to reset. </td></tr>
    <tr><td class="paramname">seed</td><td>The 64-bit seed to alter the state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>statePtr</code> must not be <code>NULL</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534abd20b092d624344e301b0cadd29d5bd6">XXH_OK</a> on success, <a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534a462a18276729783125c7116cf102667f">XXH_ERROR</a> on failure. </dd></dl>

</div>
</div>
<a id="ga0ebc78d44e7767aa2779571bd118a126" name="ga0ebc78d44e7767aa2779571bd118a126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ebc78d44e7767aa2779571bd118a126">&#9670;&#160;</a></span>XXH3_64bits_reset_withSecret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_64bits_reset_withSecret </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>secret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>secretSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___x_x_h3__family.html#ga0ebc78d44e7767aa2779571bd118a126">XXH3_64bits_reset_withSecret()</a>: <code>secret</code> is referenced, it <em>must outlive</em> the hash streaming session. Similar to one-shot API, <code>secretSize</code> must be &gt;= <code>XXH3_SECRET_SIZE_MIN</code>, and the quality of produced hash values depends on secret's entropy (secret's content should look like a bunch of random bytes). When in doubt about the randomness of a candidate <code>secret</code>, consider employing <code><a class="el" href="group___x_x_h3__family.html#ga88a3a4fbe45ae0863652178fa00465b3">XXH3_generateSecret()</a></code> instead (see below). </p>

</div>
</div>
<a id="gacca0e39d67b023700ade8b0eca4e0a13" name="gacca0e39d67b023700ade8b0eca4e0a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacca0e39d67b023700ade8b0eca4e0a13">&#9670;&#160;</a></span>XXH3_64bits_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_64bits_update </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes a block of <code>input</code> to an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>. </p>
<p>Call this to incrementally consume blocks of data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statePtr</td><td>The state struct to update. </td></tr>
    <tr><td class="paramname">input</td><td>The block of data to be hashed, at least <code>length</code> bytes in size. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <code>input</code>, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>statePtr</code> must not be <code>NULL</code>. </dd>
<dd>
The memory between <code>input</code> and <code>input</code> + <code>length</code> must be valid, readable, contiguous memory. However, if <code>length</code> is <code>0</code>, <code>input</code> may be <code>NULL</code>. In C++, this also must be <em>TriviallyCopyable</em>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534abd20b092d624344e301b0cadd29d5bd6">XXH_OK</a> on success, <a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534a462a18276729783125c7116cf102667f">XXH_ERROR</a> on failure. </dd></dl>

</div>
</div>
<a id="ga8fd6a50b808c5fc47f91ed3f5b85fcfc" name="ga8fd6a50b808c5fc47f91ed3f5b85fcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fd6a50b808c5fc47f91ed3f5b85fcfc">&#9670;&#160;</a></span>XXH3_64bits_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> XXH3_64bits_digest </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the calculated XXH3 64-bit hash value from an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Calling <a class="el" href="group___x_x_h3__family.html#ga8fd6a50b808c5fc47f91ed3f5b85fcfc" title="Returns the calculated XXH3 64-bit hash value from an XXH3_state_t.">XXH3_64bits_digest()</a> will not affect <code>statePtr</code>, so you can update, digest, and update again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statePtr</td><td>The state struct to calculate the hash from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>statePtr</code> must not be <code>NULL</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated XXH3 64-bit hash value from that state. </dd></dl>

</div>
</div>
<a id="ga8051df2b6621c36b542ae1b5df2dd2f9" name="ga8051df2b6621c36b542ae1b5df2dd2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8051df2b6621c36b542ae1b5df2dd2f9">&#9670;&#160;</a></span>XXH3_128bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> XXH3_128bits </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unseeded 128-bit variant of XXH3. </p>
<p>The 128-bit variant of XXH3 has more strength, but it has a bit of overhead for shorter inputs.</p>
<p>This is equivalent to <a class="el" href="group___x_x_h3__family.html#ga2c66790514ddccf7ac33e4ed1b1ad5e7">XXH3_128bits_withSeed()</a> with a seed of 0, however it may have slightly better performance due to constant propagation of the defaults.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___x_x_h32__family.html#ga310c01be2371883ad3bb37930626ec86" title="Calculates the 32-bit hash of input using xxHash32.">XXH32()</a>, <a class="el" href="group___x_x_h64__family.html#ga089c4003cb11acb60d3d1b439c69e336" title="Calculates the 64-bit hash of input using xxHash64.">XXH64()</a>, <a class="el" href="group___x_x_h3__family.html#ga0c06e71549705effd58cb7bd0969307e" title="64-bit unseeded variant of XXH3.">XXH3_64bits()</a>: equivalent for the other xxHash algorithms </dd>
<dd>
<a class="el" href="group___x_x_h3__family.html#ga2c66790514ddccf7ac33e4ed1b1ad5e7" title="Seeded 128-bit variant of XXH3.">XXH3_128bits_withSeed()</a>, <a class="el" href="group___x_x_h3__family.html#ga192ce854fdff8d491ec5201268007401" title="Custom secret 128-bit variant of XXH3.">XXH3_128bits_withSecret()</a>: other seeding variants </dd>
<dd>
<a class="el" href="group___x_x_h3__family.html#gaf4fef3307630a356a65eaf1589db53c0" title="Resets an XXH3_state_t to begin a new hash.">XXH3_128bits_reset()</a>, <a class="el" href="group___x_x_h3__family.html#ga08cea3acdfdc9bc7102c4ae133ef702a" title="Consumes a block of input to an XXH3_state_t.">XXH3_128bits_update()</a>, <a class="el" href="group___x_x_h3__family.html#ga1239aeb6d2b2604f8d227ff5546473f8" title="Returns the calculated XXH3 128-bit hash value from an XXH3_state_t.">XXH3_128bits_digest()</a>: Streaming version. </dd></dl>

</div>
</div>
<a id="ga2c66790514ddccf7ac33e4ed1b1ad5e7" name="ga2c66790514ddccf7ac33e4ed1b1ad5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c66790514ddccf7ac33e4ed1b1ad5e7">&#9670;&#160;</a></span>XXH3_128bits_withSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> XXH3_128bits_withSeed </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seeded 128-bit variant of XXH3. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___x_x_h3__family.html#ga4b51002ff2a438e38c1ee45abcd09659" title="64-bit seeded variant of XXH3">XXH3_64bits_withSeed()</a>. </dd></dl>

</div>
</div>
<a id="ga192ce854fdff8d491ec5201268007401" name="ga192ce854fdff8d491ec5201268007401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga192ce854fdff8d491ec5201268007401">&#9670;&#160;</a></span>XXH3_128bits_withSecret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> XXH3_128bits_withSecret </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>secret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>secretSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom secret 128-bit variant of XXH3. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___x_x_h3__family.html#ga870ba5470efb3befb1a70cb35dae12cd" title="64-bit variant of XXH3 with a custom &quot;secret&quot;.">XXH3_64bits_withSecret()</a>. </dd></dl>

</div>
</div>
<a id="gaf4fef3307630a356a65eaf1589db53c0" name="gaf4fef3307630a356a65eaf1589db53c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4fef3307630a356a65eaf1589db53c0">&#9670;&#160;</a></span>XXH3_128bits_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_128bits_reset </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> to begin a new hash. </p>
<p>This function resets <code>statePtr</code> and generate a secret with default parameters. Call it before <a class="el" href="group___x_x_h3__family.html#ga08cea3acdfdc9bc7102c4ae133ef702a">XXH3_128bits_update()</a>. Digest will be equivalent to <code><a class="el" href="group___x_x_h3__family.html#ga8051df2b6621c36b542ae1b5df2dd2f9" title="Unseeded 128-bit variant of XXH3.">XXH3_128bits()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statePtr</td><td>The state struct to reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>statePtr</code> must not be <code>NULL</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534abd20b092d624344e301b0cadd29d5bd6">XXH_OK</a> on success, <a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534a462a18276729783125c7116cf102667f">XXH_ERROR</a> on failure. </dd></dl>

</div>
</div>
<a id="ga7e225fe11a64c6a3a4a95668d8389794" name="ga7e225fe11a64c6a3a4a95668d8389794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e225fe11a64c6a3a4a95668d8389794">&#9670;&#160;</a></span>XXH3_128bits_reset_withSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_128bits_reset_withSeed </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> with 64-bit seed to begin a new hash. </p>
<p>This function resets <code>statePtr</code> and generate a secret from <code>seed</code>. Call it before <a class="el" href="group___x_x_h3__family.html#ga08cea3acdfdc9bc7102c4ae133ef702a">XXH3_128bits_update()</a>. Digest will be equivalent to <code><a class="el" href="group___x_x_h3__family.html#ga2c66790514ddccf7ac33e4ed1b1ad5e7" title="Seeded 128-bit variant of XXH3.">XXH3_128bits_withSeed()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statePtr</td><td>The state struct to reset. </td></tr>
    <tr><td class="paramname">seed</td><td>The 64-bit seed to alter the state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>statePtr</code> must not be <code>NULL</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534abd20b092d624344e301b0cadd29d5bd6">XXH_OK</a> on success, <a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534a462a18276729783125c7116cf102667f">XXH_ERROR</a> on failure. </dd></dl>

</div>
</div>
<a id="ga16f78f1d03c546e274ee18fe32ed2f6b" name="ga16f78f1d03c546e274ee18fe32ed2f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16f78f1d03c546e274ee18fe32ed2f6b">&#9670;&#160;</a></span>XXH3_128bits_reset_withSecret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_128bits_reset_withSecret </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>secret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>secretSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom secret 128-bit variant of XXH3. </p>
<dl class="section see"><dt>See also</dt><dd>XXH_64bits_reset_withSecret(). </dd></dl>

</div>
</div>
<a id="ga08cea3acdfdc9bc7102c4ae133ef702a" name="ga08cea3acdfdc9bc7102c4ae133ef702a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08cea3acdfdc9bc7102c4ae133ef702a">&#9670;&#160;</a></span>XXH3_128bits_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_128bits_update </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes a block of <code>input</code> to an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>. </p>
<p>Call this to incrementally consume blocks of data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statePtr</td><td>The state struct to update. </td></tr>
    <tr><td class="paramname">input</td><td>The block of data to be hashed, at least <code>length</code> bytes in size. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <code>input</code>, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>statePtr</code> must not be <code>NULL</code>. </dd>
<dd>
The memory between <code>input</code> and <code>input</code> + <code>length</code> must be valid, readable, contiguous memory. However, if <code>length</code> is <code>0</code>, <code>input</code> may be <code>NULL</code>. In C++, this also must be <em>TriviallyCopyable</em>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534abd20b092d624344e301b0cadd29d5bd6">XXH_OK</a> on success, <a class="el" href="group__public.html#gga5020905455674b8c83c1dbc73f0d3534a462a18276729783125c7116cf102667f">XXH_ERROR</a> on failure. </dd></dl>

</div>
</div>
<a id="ga1239aeb6d2b2604f8d227ff5546473f8" name="ga1239aeb6d2b2604f8d227ff5546473f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1239aeb6d2b2604f8d227ff5546473f8">&#9670;&#160;</a></span>XXH3_128bits_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> XXH3_128bits_digest </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the calculated XXH3 128-bit hash value from an <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Calling <a class="el" href="group___x_x_h3__family.html#ga1239aeb6d2b2604f8d227ff5546473f8" title="Returns the calculated XXH3 128-bit hash value from an XXH3_state_t.">XXH3_128bits_digest()</a> will not affect <code>statePtr</code>, so you can update, digest, and update again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statePtr</td><td>The state struct to calculate the hash from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>statePtr</code> must not be <code>NULL</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated XXH3 128-bit hash value from that state. </dd></dl>

</div>
</div>
<a id="gae48a69e41062619715826660580d42ab" name="gae48a69e41062619715826660580d42ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae48a69e41062619715826660580d42ab">&#9670;&#160;</a></span>XXH128_isEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XXH128_isEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>&#160;</td>
          <td class="paramname"><em>h2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___x_x_h3__family.html#gae48a69e41062619715826660580d42ab">XXH128_isEqual()</a>: Return: 1 if <code>h1</code> and <code>h2</code> are equal, 0 if they are not. </p>

</div>
</div>
<a id="ga6f31fe3cef649f8b78fca6e5040f9b74" name="ga6f31fe3cef649f8b78fca6e5040f9b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f31fe3cef649f8b78fca6e5040f9b74">&#9670;&#160;</a></span>XXH128_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XXH128_cmp </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>h128_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>h128_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> This comparator is compatible with stdlib's <code>qsort()</code>/<code>bsearch()</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>: &gt;0 if *h128_1 &gt; *h128_2 =0 if *h128_1 == *h128_2 &lt;0 if *h128_1 &lt; *h128_2 </dd></dl>

</div>
</div>
<a id="ga04a6b47e068251634e4984117eae520a" name="ga04a6b47e068251634e4984117eae520a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04a6b47e068251634e4984117eae520a">&#9670;&#160;</a></span>XXH128_canonicalFromHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XXH128_canonicalFromHash </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="struct_x_x_h128__canonical__t.html">XXH128_canonical_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> to a big endian <a class="el" href="struct_x_x_h128__canonical__t.html">XXH128_canonical_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The <a class="el" href="struct_x_x_h128__canonical__t.html">XXH128_canonical_t</a> pointer to be stored to. </td></tr>
    <tr><td class="paramname">hash</td><td>The <a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>dst</code> must not be <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="ga9fe959cfcddb1dad57a532eb57d22661" name="ga9fe959cfcddb1dad57a532eb57d22661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fe959cfcddb1dad57a532eb57d22661">&#9670;&#160;</a></span>XXH128_hashFromCanonical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> XXH128_hashFromCanonical </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const <a class="el" href="struct_x_x_h128__canonical__t.html">XXH128_canonical_t</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="struct_x_x_h128__canonical__t.html">XXH128_canonical_t</a> to a native <a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The <a class="el" href="struct_x_x_h128__canonical__t.html">XXH128_canonical_t</a> to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>src</code> must not be <code>NULL</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The converted hash. </dd></dl>

</div>
</div>
<a id="ga2680c1ef72d4deab6fe8e00b7eb83ee5" name="ga2680c1ef72d4deab6fe8e00b7eb83ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2680c1ef72d4deab6fe8e00b7eb83ee5">&#9670;&#160;</a></span>XXH3_64bits_reset_withSecretandSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_64bits_reset_withSecretandSeed </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>secret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>secretSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td>
          <td class="paramname"><em>seed64</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>These variants generate hash values using either <code>seed</code> for "short" keys (&lt; XXH3_MIDSIZE_MAX = 240 bytes) or <code>secret</code> for "large" keys (&gt;= XXH3_MIDSIZE_MAX).</p>
<p>This generally benefits speed, compared to <code>_withSeed()</code> or <code>_withSecret()</code>. <code>_withSeed()</code> has to generate the secret on the fly for "large" keys. It's fast, but can be perceptible for "not so large" keys (&lt; 1 KB). <code>_withSecret()</code> has to generate the masks on the fly for "small" keys, which requires more instructions than _withSeed() variants. Therefore, _withSecretandSeed variant combines the best of both worlds.</p>
<p>When <code>secret</code> has been generated by <a class="el" href="group___x_x_h3__family.html#gaa895f02acfc127b1d34d0d558a6773b0" title="Generate the same secret as the _withSeed() variants.">XXH3_generateSecret_fromSeed()</a>, this variant produces <em>exactly</em> the same results as <code>_withSeed()</code> variant, hence offering only a pure speed benefit on "large" input, by skipping the need to regenerate the secret for every large input.</p>
<p>Another usage scenario is to hash the secret to a 64-bit hash value, for example with <a class="el" href="group___x_x_h3__family.html#ga0c06e71549705effd58cb7bd0969307e" title="64-bit unseeded variant of XXH3.">XXH3_64bits()</a>, which then becomes the seed, and then employ both the seed and the secret in _withSecretandSeed(). On top of speed, an added benefit is that each bit in the secret has a 50% chance to swap each bit in the output, via its impact to the seed.</p>
<p>This is not guaranteed when using the secret directly in "small data" scenarios, because only portions of the secret are employed for small data.   </p>

</div>
</div>
<a id="ga7c198e9d131046515c7d6a2d65d099b7" name="ga7c198e9d131046515c7d6a2d65d099b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c198e9d131046515c7d6a2d65d099b7">&#9670;&#160;</a></span>XXH3_128bits_withSecretandSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> XXH3_128bits_withSecretandSeed </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>secret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>secretSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td>
          <td class="paramname"><em>seed64</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>These variants generate hash values using either <code>seed</code> for "short" keys (&lt; XXH3_MIDSIZE_MAX = 240 bytes) or <code>secret</code> for "large" keys (&gt;= XXH3_MIDSIZE_MAX).</p>
<p>This generally benefits speed, compared to <code>_withSeed()</code> or <code>_withSecret()</code>. <code>_withSeed()</code> has to generate the secret on the fly for "large" keys. It's fast, but can be perceptible for "not so large" keys (&lt; 1 KB). <code>_withSecret()</code> has to generate the masks on the fly for "small" keys, which requires more instructions than _withSeed() variants. Therefore, _withSecretandSeed variant combines the best of both worlds.</p>
<p>When <code>secret</code> has been generated by <a class="el" href="group___x_x_h3__family.html#gaa895f02acfc127b1d34d0d558a6773b0" title="Generate the same secret as the _withSeed() variants.">XXH3_generateSecret_fromSeed()</a>, this variant produces <em>exactly</em> the same results as <code>_withSeed()</code> variant, hence offering only a pure speed benefit on "large" input, by skipping the need to regenerate the secret for every large input.</p>
<p>Another usage scenario is to hash the secret to a 64-bit hash value, for example with <a class="el" href="group___x_x_h3__family.html#ga0c06e71549705effd58cb7bd0969307e" title="64-bit unseeded variant of XXH3.">XXH3_64bits()</a>, which then becomes the seed, and then employ both the seed and the secret in _withSecretandSeed(). On top of speed, an added benefit is that each bit in the secret has a 50% chance to swap each bit in the output, via its impact to the seed.</p>
<p>This is not guaranteed when using the secret directly in "small data" scenarios, because only portions of the secret are employed for small data.   </p>

</div>
</div>
<a id="ga7090a47ff2c03b7da2082d776610aa95" name="ga7090a47ff2c03b7da2082d776610aa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7090a47ff2c03b7da2082d776610aa95">&#9670;&#160;</a></span>XXH128()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_x_h128__hash__t.html">XXH128_hash_t</a> XXH128 </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>simple alias to pre-selected XXH3_128bits variant </p>

</div>
</div>
<a id="ga57580a70118de171d0236b415d488b3e" name="ga57580a70118de171d0236b415d488b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57580a70118de171d0236b415d488b3e">&#9670;&#160;</a></span>XXH3_128bits_reset_withSecretandSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_128bits_reset_withSecretandSeed </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE <a class="el" href="group___x_x_h3__family.html#ga8e454084a62efb09fad8ba3cc1c1b1d0">XXH3_state_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>secret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>secretSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td>
          <td class="paramname"><em>seed64</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>These variants generate hash values using either <code>seed</code> for "short" keys (&lt; XXH3_MIDSIZE_MAX = 240 bytes) or <code>secret</code> for "large" keys (&gt;= XXH3_MIDSIZE_MAX).</p>
<p>This generally benefits speed, compared to <code>_withSeed()</code> or <code>_withSecret()</code>. <code>_withSeed()</code> has to generate the secret on the fly for "large" keys. It's fast, but can be perceptible for "not so large" keys (&lt; 1 KB). <code>_withSecret()</code> has to generate the masks on the fly for "small" keys, which requires more instructions than _withSeed() variants. Therefore, _withSecretandSeed variant combines the best of both worlds.</p>
<p>When <code>secret</code> has been generated by <a class="el" href="group___x_x_h3__family.html#gaa895f02acfc127b1d34d0d558a6773b0" title="Generate the same secret as the _withSeed() variants.">XXH3_generateSecret_fromSeed()</a>, this variant produces <em>exactly</em> the same results as <code>_withSeed()</code> variant, hence offering only a pure speed benefit on "large" input, by skipping the need to regenerate the secret for every large input.</p>
<p>Another usage scenario is to hash the secret to a 64-bit hash value, for example with <a class="el" href="group___x_x_h3__family.html#ga0c06e71549705effd58cb7bd0969307e" title="64-bit unseeded variant of XXH3.">XXH3_64bits()</a>, which then becomes the seed, and then employ both the seed and the secret in _withSecretandSeed(). On top of speed, an added benefit is that each bit in the secret has a 50% chance to swap each bit in the output, via its impact to the seed.</p>
<p>This is not guaranteed when using the secret directly in "small data" scenarios, because only portions of the secret are employed for small data.   </p>

</div>
</div>
<a id="ga88a3a4fbe45ae0863652178fa00465b3" name="ga88a3a4fbe45ae0863652178fa00465b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88a3a4fbe45ae0863652178fa00465b3">&#9670;&#160;</a></span>XXH3_generateSecret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public.html#ga5020905455674b8c83c1dbc73f0d3534">XXH_errorcode</a> XXH3_generateSecret </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE void *&#160;</td>
          <td class="paramname"><em>secretBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>secretSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XXH_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>customSeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>customSeedSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___x_x_h3__family.html#ga88a3a4fbe45ae0863652178fa00465b3">XXH3_generateSecret()</a>:</p>
<p>Derive a high-entropy secret from any user-defined content, named customSeed. The generated secret can be used in combination with <code>*_withSecret()</code> functions. The <code>_withSecret()</code> variants are useful to provide a higher level of protection than 64-bit seed, as it becomes much more difficult for an external actor to guess how to impact the calculation logic.</p>
<p>The function accepts as input a custom seed of any length and any content, and derives from it a high-entropy secret of length <code>secretSize</code> into an already allocated buffer <code>secretBuffer</code>.</p>
<p>The generated secret can then be used with any <code>*_withSecret()</code> variant. The functions <a class="el" href="group___x_x_h3__family.html#ga192ce854fdff8d491ec5201268007401">XXH3_128bits_withSecret()</a>, <a class="el" href="group___x_x_h3__family.html#ga870ba5470efb3befb1a70cb35dae12cd">XXH3_64bits_withSecret()</a>, <a class="el" href="group___x_x_h3__family.html#ga16f78f1d03c546e274ee18fe32ed2f6b">XXH3_128bits_reset_withSecret()</a> and <a class="el" href="group___x_x_h3__family.html#ga0ebc78d44e7767aa2779571bd118a126">XXH3_64bits_reset_withSecret()</a> are part of this list. They all accept a <code>secret</code> parameter which must be large enough for implementation reasons (&gt;= <a class="el" href="group___x_x_h3__family.html#gaeb79a9111c58af32599f8e5cd71d67d2">XXH3_SECRET_SIZE_MIN</a>) <em>and</em> feature very high entropy (consist of random-looking bytes). These conditions can be a high bar to meet, so <a class="el" href="group___x_x_h3__family.html#ga88a3a4fbe45ae0863652178fa00465b3">XXH3_generateSecret()</a> can be employed to ensure proper quality.</p>
<p><code>customSeed</code> can be anything. It can have any size, even small ones, and its content can be anything, even "poor entropy" sources such as a bunch of zeroes. The resulting <code>secret</code> will nonetheless provide all required qualities.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code>secretSize</code> must be &gt;= <a class="el" href="group___x_x_h3__family.html#gaeb79a9111c58af32599f8e5cd71d67d2">XXH3_SECRET_SIZE_MIN</a></li>
<li>When <code>customSeedSize</code> &gt; 0, supplying NULL as customSeed is undefined behavior.</li>
</ul>
</dd></dl>
<p>Example code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define XXH_STATIC_LINKING_ONLY </span><span class="comment">// expose unstable API</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="xxhash_8h.html">xxhash.h</a>&quot;</span></div>
<div class="line"><span class="comment">// Hashes argv[2] using the entropy from argv[1].</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> secret[<a class="code hl_define" href="group___x_x_h3__family.html#gaeb79a9111c58af32599f8e5cd71d67d2">XXH3_SECRET_SIZE_MIN</a>];</div>
<div class="line">    <span class="keywordflow">if</span> (argv != 3) { <span class="keywordflow">return</span> 1; }</div>
<div class="line">    <a class="code hl_function" href="group___x_x_h3__family.html#ga88a3a4fbe45ae0863652178fa00465b3">XXH3_generateSecret</a>(secret, <span class="keyword">sizeof</span>(secret), argv[1], strlen(argv[1]));</div>
<div class="line">    <a class="code hl_typedef" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> h = <a class="code hl_function" href="group___x_x_h3__family.html#ga870ba5470efb3befb1a70cb35dae12cd">XXH3_64bits_withSecret</a>(</div>
<div class="line">         argv[2], strlen(argv[2]),</div>
<div class="line">         secret, <span class="keyword">sizeof</span>(secret)</div>
<div class="line">    );</div>
<div class="line">    printf(<span class="stringliteral">&quot;%016llx\n&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) h);</div>
<div class="line">}</div>
<div class="ttc" id="agroup___x_x_h3__family_html_ga870ba5470efb3befb1a70cb35dae12cd"><div class="ttname"><a href="group___x_x_h3__family.html#ga870ba5470efb3befb1a70cb35dae12cd">XXH3_64bits_withSecret</a></div><div class="ttdeci">XXH64_hash_t XXH3_64bits_withSecret(XXH_NOESCAPE const void *data, size_t len, XXH_NOESCAPE const void *secret, size_t secretSize)</div><div class="ttdoc">64-bit variant of XXH3 with a custom &quot;secret&quot;.</div><div class="ttdef"><b>Definition</b> xxhash.h:5726</div></div>
<div class="ttc" id="agroup___x_x_h3__family_html_ga88a3a4fbe45ae0863652178fa00465b3"><div class="ttname"><a href="group___x_x_h3__family.html#ga88a3a4fbe45ae0863652178fa00465b3">XXH3_generateSecret</a></div><div class="ttdeci">XXH_errorcode XXH3_generateSecret(XXH_NOESCAPE void *secretBuffer, size_t secretSize, XXH_NOESCAPE const void *customSeed, size_t customSeedSize)</div><div class="ttdef"><b>Definition</b> xxhash.h:6699</div></div>
<div class="ttc" id="agroup___x_x_h3__family_html_gaeb79a9111c58af32599f8e5cd71d67d2"><div class="ttname"><a href="group___x_x_h3__family.html#gaeb79a9111c58af32599f8e5cd71d67d2">XXH3_SECRET_SIZE_MIN</a></div><div class="ttdeci">#define XXH3_SECRET_SIZE_MIN</div><div class="ttdef"><b>Definition</b> xxhash.h:1093</div></div>
<div class="ttc" id="agroup__public_html_ga5406b285b18dfcefa93efed489e3b603"><div class="ttname"><a href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a></div><div class="ttdeci">uint64_t XXH64_hash_t</div><div class="ttdoc">An unsigned 64-bit integer.</div><div class="ttdef"><b>Definition</b> xxhash.h:820</div></div>
<div class="ttc" id="axxhash_8h_html"><div class="ttname"><a href="xxhash_8h.html">xxhash.h</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa895f02acfc127b1d34d0d558a6773b0" name="gaa895f02acfc127b1d34d0d558a6773b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa895f02acfc127b1d34d0d558a6773b0">&#9670;&#160;</a></span>XXH3_generateSecret_fromSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XXH3_generateSecret_fromSeed </td>
          <td>(</td>
          <td class="paramtype">XXH_NOESCAPE void *&#160;</td>
          <td class="paramname"><em>secretBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a>&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the same secret as the _withSeed() variants. </p>
<p>The generated secret can be used in combination with <code>*_withSecret()</code> and <code>_withSecretandSeed()</code> variants.</p>
<p>Example C++ <code>std::string</code> hash class: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#define XXH_STATIC_LINKING_ONLY </span><span class="comment">// expose unstable API</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="xxhash_8h.html">xxhash.h</a>&quot;</span></div>
<div class="line"><span class="comment">// Slow, seeds each time</span></div>
<div class="line"><span class="keyword">class </span>HashSlow {</div>
<div class="line">    <a class="code hl_typedef" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> seed;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    HashSlow(<a class="code hl_typedef" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> s) : seed{s} {}</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()(<span class="keyword">const</span> std::string&amp; x)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keywordtype">size_t</span>{<a class="code hl_function" href="group___x_x_h3__family.html#ga4b51002ff2a438e38c1ee45abcd09659">XXH3_64bits_withSeed</a>(x.c_str(), x.length(), seed)};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="comment">// Fast, caches the seeded secret for future uses.</span></div>
<div class="line"><span class="keyword">class </span>HashFast {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> secret[<a class="code hl_define" href="group___x_x_h3__family.html#gaeb79a9111c58af32599f8e5cd71d67d2">XXH3_SECRET_SIZE_MIN</a>];</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    HashFast(<a class="code hl_typedef" href="group__public.html#ga5406b285b18dfcefa93efed489e3b603">XXH64_hash_t</a> s) {</div>
<div class="line">        <a class="code hl_function" href="group___x_x_h3__family.html#gaa895f02acfc127b1d34d0d558a6773b0">XXH3_generateSecret_fromSeed</a>(secret, seed);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()(<span class="keyword">const</span> std::string&amp; x)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keywordtype">size_t</span>{</div>
<div class="line">            <a class="code hl_function" href="group___x_x_h3__family.html#ga870ba5470efb3befb1a70cb35dae12cd">XXH3_64bits_withSecret</a>(x.c_str(), x.length(), secret, <span class="keyword">sizeof</span>(secret))</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="agroup___x_x_h3__family_html_ga4b51002ff2a438e38c1ee45abcd09659"><div class="ttname"><a href="group___x_x_h3__family.html#ga4b51002ff2a438e38c1ee45abcd09659">XXH3_64bits_withSeed</a></div><div class="ttdeci">XXH64_hash_t XXH3_64bits_withSeed(XXH_NOESCAPE const void *input, size_t length, XXH64_hash_t seed)</div><div class="ttdoc">64-bit seeded variant of XXH3</div><div class="ttdef"><b>Definition</b> xxhash.h:5733</div></div>
<div class="ttc" id="agroup___x_x_h3__family_html_gaa895f02acfc127b1d34d0d558a6773b0"><div class="ttname"><a href="group___x_x_h3__family.html#gaa895f02acfc127b1d34d0d558a6773b0">XXH3_generateSecret_fromSeed</a></div><div class="ttdeci">void XXH3_generateSecret_fromSeed(XXH_NOESCAPE void *secretBuffer, XXH64_hash_t seed)</div><div class="ttdoc">Generate the same secret as the _withSeed() variants.</div><div class="ttdef"><b>Definition</b> xxhash.h:6744</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secretBuffer</td><td>A writable buffer of <a class="el" href="group___x_x_h3__family.html#gaeb79a9111c58af32599f8e5cd71d67d2">XXH3_SECRET_SIZE_MIN</a> bytes </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to seed the state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
