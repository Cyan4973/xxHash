<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xxHash: Tuning parameters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">xxHash<span id="projectnumber">&#160;0.8.2</span>
   </div>
   <div id="projectbrief">Extremely fast non-cryptographic hash function</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle"><div class="title">Tuning parameters</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7e738bf7fb8249e8a834a8c8a8581d80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#ga7e738bf7fb8249e8a834a8c8a8581d80">XXH_NO_LONG_LONG</a></td></tr>
<tr class="memdesc:ga7e738bf7fb8249e8a834a8c8a8581d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define this to disable 64-bit code.  <br /></td></tr>
<tr class="separator:ga7e738bf7fb8249e8a834a8c8a8581d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b48241beb7c34e5929d328cf5cc71a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#ga04b48241beb7c34e5929d328cf5cc71a">XXH_FORCE_MEMORY_ACCESS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga04b48241beb7c34e5929d328cf5cc71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls how unaligned memory is accessed.  <br /></td></tr>
<tr class="separator:ga04b48241beb7c34e5929d328cf5cc71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9850064fc149181cce7431f40a990a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#ga1e9850064fc149181cce7431f40a990a">XXH_SIZE_OPT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga1e9850064fc149181cce7431f40a990a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls how much xxHash optimizes for size.  <br /></td></tr>
<tr class="separator:ga1e9850064fc149181cce7431f40a990a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee35763869a969d5576e70dac1c08b8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#gaee35763869a969d5576e70dac1c08b8d">XXH_FORCE_ALIGN_CHECK</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaee35763869a969d5576e70dac1c08b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If defined to non-zero, adds a special path for aligned inputs (<a class="el" href="group___x_x_h32__family.html#ga310c01be2371883ad3bb37930626ec86" title="Calculates the 32-bit hash of input using xxHash32.">XXH32()</a> and <a class="el" href="group___x_x_h64__family.html#ga089c4003cb11acb60d3d1b439c69e336" title="Calculates the 64-bit hash of input using xxHash64.">XXH64()</a> only).  <br /></td></tr>
<tr class="separator:gaee35763869a969d5576e70dac1c08b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae980c41901d840d8909aa74d603ad4f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#gae980c41901d840d8909aa74d603ad4f1">XXH_NO_INLINE_HINTS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gae980c41901d840d8909aa74d603ad4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">When non-zero, sets all functions to <code>static</code>.  <br /></td></tr>
<tr class="separator:gae980c41901d840d8909aa74d603ad4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d5f6ddf0a7d14b90a63cb6a9d34c26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#gaa6d5f6ddf0a7d14b90a63cb6a9d34c26">XXH3_INLINE_SECRET</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaa6d5f6ddf0a7d14b90a63cb6a9d34c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether to inline the XXH3 withSecret code.  <br /></td></tr>
<tr class="separator:gaa6d5f6ddf0a7d14b90a63cb6a9d34c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5824529c4ad74d2d5cc05bf4868613a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#gad5824529c4ad74d2d5cc05bf4868613a">XXH32_ENDJMP</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gad5824529c4ad74d2d5cc05bf4868613a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to use a jump for <code>XXH32_finalize</code>.  <br /></td></tr>
<tr class="separator:gad5824529c4ad74d2d5cc05bf4868613a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80dc258deeac9258924815d7b3d11906"><td class="memItemLeft" align="right" valign="top"><a id="ga80dc258deeac9258924815d7b3d11906" name="ga80dc258deeac9258924815d7b3d11906"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_OLD_NAMES</b></td></tr>
<tr class="separator:ga80dc258deeac9258924815d7b3d11906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96f0b839b3187287c904d37c993f6d1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#ga96f0b839b3187287c904d37c993f6d1f">XXH_NO_STREAM</a></td></tr>
<tr class="memdesc:ga96f0b839b3187287c904d37c993f6d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the streaming API.  <br /></td></tr>
<tr class="separator:ga96f0b839b3187287c904d37c993f6d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574ceb8ab088243cb0dc833b28320eb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#ga574ceb8ab088243cb0dc833b28320eb5">XXH_DEBUGLEVEL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga574ceb8ab088243cb0dc833b28320eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debugging level.  <br /></td></tr>
<tr class="separator:ga574ceb8ab088243cb0dc833b28320eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga408fac02658eb4a81f7a1877f1ca3b3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#ga408fac02658eb4a81f7a1877f1ca3b3f">XXH_CPU_LITTLE_ENDIAN</a>&#160;&#160;&#160;XXH_isLittleEndian()</td></tr>
<tr class="memdesc:ga408fac02658eb4a81f7a1877f1ca3b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the target is little endian.  <br /></td></tr>
<tr class="separator:ga408fac02658eb4a81f7a1877f1ca3b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab216d0cd3d35dcfd7c6860ea296cdd86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#gab216d0cd3d35dcfd7c6860ea296cdd86">XXH_VECTOR</a>&#160;&#160;&#160;<a class="el" href="group__tuning.html#ggaba09620eec7211bfe2567531495bf151add8559df4f18bb2868e3c2bd5fa69a5e">XXH_SCALAR</a></td></tr>
<tr class="memdesc:gab216d0cd3d35dcfd7c6860ea296cdd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides the vectorization implementation chosen for XXH3.  <br /></td></tr>
<tr class="separator:gab216d0cd3d35dcfd7c6860ea296cdd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab216d0cd3d35dcfd7c6860ea296cdd86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#gab216d0cd3d35dcfd7c6860ea296cdd86">XXH_VECTOR</a>&#160;&#160;&#160;<a class="el" href="group__tuning.html#ggaba09620eec7211bfe2567531495bf151add8559df4f18bb2868e3c2bd5fa69a5e">XXH_SCALAR</a></td></tr>
<tr class="memdesc:gab216d0cd3d35dcfd7c6860ea296cdd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides the vectorization implementation chosen for XXH3.  <br /></td></tr>
<tr class="separator:gab216d0cd3d35dcfd7c6860ea296cdd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15f2f40c9206c691f66cf260841f8ad1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#ga15f2f40c9206c691f66cf260841f8ad1">XXH_ACC_ALIGN</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga15f2f40c9206c691f66cf260841f8ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the minimum alignment for XXH3's accumulators.  <br /></td></tr>
<tr class="separator:ga15f2f40c9206c691f66cf260841f8ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac799ce966f18e4837f7fdc3d51917e9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#gac799ce966f18e4837f7fdc3d51917e9c">XXH3_NEON_LANES</a>&#160;&#160;&#160;XXH_ACC_NB</td></tr>
<tr class="memdesc:gac799ce966f18e4837f7fdc3d51917e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the NEON to scalar ratio for XXH3.  <br /></td></tr>
<tr class="separator:gac799ce966f18e4837f7fdc3d51917e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaba09620eec7211bfe2567531495bf151"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#gaba09620eec7211bfe2567531495bf151">XXH_VECTOR_TYPE</a> { <br />
&#160;&#160;<a class="el" href="group__tuning.html#ggaba09620eec7211bfe2567531495bf151add8559df4f18bb2868e3c2bd5fa69a5e">XXH_SCALAR</a> = 0
, <a class="el" href="group__tuning.html#ggaba09620eec7211bfe2567531495bf151a47d2060710fcee22a971c9912f902aa4">XXH_SSE2</a> = 1
, <a class="el" href="group__tuning.html#ggaba09620eec7211bfe2567531495bf151a96572760b51d70b97f5db1ebf0a95995">XXH_AVX2</a> = 2
, <a class="el" href="group__tuning.html#ggaba09620eec7211bfe2567531495bf151a38698e7f6fc187288a40dcf362006c29">XXH_AVX512</a> = 3
, <br />
&#160;&#160;<a class="el" href="group__tuning.html#ggaba09620eec7211bfe2567531495bf151a2b9cfb9a77ed183f8551243bb2f490cb">XXH_NEON</a> = 4
, <a class="el" href="group__tuning.html#ggaba09620eec7211bfe2567531495bf151a62278d38bf34bac7e8f5bbe354a46449">XXH_VSX</a> = 5
, <a class="el" href="group__tuning.html#ggaba09620eec7211bfe2567531495bf151aedef83e5c7f75801acbde3ea771fe9f1">XXH_SVE</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:gaba09620eec7211bfe2567531495bf151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible values for <a class="el" href="group__tuning.html#gab216d0cd3d35dcfd7c6860ea296cdd86">XXH_VECTOR</a>.  <a href="group__tuning.html#gaba09620eec7211bfe2567531495bf151">More...</a><br /></td></tr>
<tr class="separator:gaba09620eec7211bfe2567531495bf151"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Various macros to control xxHash's behavior. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga7e738bf7fb8249e8a834a8c8a8581d80" name="ga7e738bf7fb8249e8a834a8c8a8581d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e738bf7fb8249e8a834a8c8a8581d80">&#9670;&#160;</a></span>XXH_NO_LONG_LONG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_NO_LONG_LONG</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define this to disable 64-bit code. </p>
<p>Useful if only using the <a class="el" href="group___x_x_h32__family.html">XXH32 family</a> and you have a strict C90 compiler. </p>

</div>
</div>
<a id="ga04b48241beb7c34e5929d328cf5cc71a" name="ga04b48241beb7c34e5929d328cf5cc71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04b48241beb7c34e5929d328cf5cc71a">&#9670;&#160;</a></span>XXH_FORCE_MEMORY_ACCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_FORCE_MEMORY_ACCESS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls how unaligned memory is accessed. </p>
<p>By default, access to unaligned memory is controlled by <code>memcpy()</code>, which is safe and portable.</p>
<p>Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.</p>
<p>The below switch allow selection of a different access method in the search for improved performance.</p>
<dl class="section user"><dt>Possible options:</dt><dd></dd></dl>
<ul>
<li><code>XXH_FORCE_MEMORY_ACCESS=0</code> (default): <code>memcpy</code> <dl class="section user"><dt></dt><dd>Use <code>memcpy()</code>. Safe and portable. Note that most modern compilers will eliminate the function call and treat it as an unaligned access.</dd></dl>
</li>
<li><code>XXH_FORCE_MEMORY_ACCESS=1</code>: <code>__attribute__((aligned(1)))</code> <dl class="section user"><dt></dt><dd>Depends on compiler extensions and is therefore not portable. This method is safe <em>if</em> your compiler supports it, and <em>generally</em> as fast or faster than <code>memcpy</code>.</dd></dl>
</li>
<li><code>XXH_FORCE_MEMORY_ACCESS=2</code>: Direct cast <dl class="section user"><dt></dt><dd>Casts directly and dereferences. This method doesn't depend on the compiler, but it violates the C standard as it directly dereferences an unaligned pointer. It can generate buggy code on targets which do not support unaligned memory accesses, but in some circumstances, it's the only known way to get the most performance.</dd></dl>
</li>
<li><code>XXH_FORCE_MEMORY_ACCESS=3</code>: Byteshift <dl class="section user"><dt></dt><dd>Also portable. This can generate the best code on old compilers which don't inline small <code>memcpy()</code> calls, and it might also be faster on big-endian systems which lack a native byteswap instruction. However, some compilers will emit literal byteshifts even if the target supports unaligned access.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Methods 1 and 2 rely on implementation-defined behavior. Use these with care, as what works on one compiler/platform/optimization level may cause another to read garbage data or even crash.</dd></dl>
See <a href="https://fastcompression.blogspot.com/2015/08/accessing-unaligned-memory.html">https://fastcompression.blogspot.com/2015/08/accessing-unaligned-memory.html</a> for details.</li>
</ul>
<p>Prefer these methods in priority order (0 &gt; 3 &gt; 1 &gt; 2) </p>

</div>
</div>
<a id="ga1e9850064fc149181cce7431f40a990a" name="ga1e9850064fc149181cce7431f40a990a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e9850064fc149181cce7431f40a990a">&#9670;&#160;</a></span>XXH_SIZE_OPT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_SIZE_OPT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls how much xxHash optimizes for size. </p>
<p>xxHash, when compiled, tends to result in a rather large binary size. This is mostly due to heavy usage to forced inlining and constant folding of the <a class="el" href="group___x_x_h3__family.html">XXH3 family</a> to increase performance.</p>
<p>However, some developers prefer size over speed. This option can significantly reduce the size of the generated code. When using the <code>-Os</code> or <code>-Oz</code> options on GCC or Clang, this is defined to 1 by default, otherwise it is defined to 0.</p>
<p>Most of these size optimizations can be controlled manually.</p>
<p>This is a number from 0-2.</p><ul>
<li><code>XXH_SIZE_OPT</code> == 0: Default. xxHash makes no size optimizations. Speed comes first.</li>
<li><code>XXH_SIZE_OPT</code> == 1: Default for <code>-Os</code> and <code>-Oz</code>. xxHash is more conservative and disables hacks that increase code size. It implies the options <a class="el" href="group__tuning.html#gae980c41901d840d8909aa74d603ad4f1">XXH_NO_INLINE_HINTS</a> == 1, <a class="el" href="group__tuning.html#gaee35763869a969d5576e70dac1c08b8d">XXH_FORCE_ALIGN_CHECK</a> == 0, and <a class="el" href="group__tuning.html#gac799ce966f18e4837f7fdc3d51917e9c">XXH3_NEON_LANES</a> == 8 if they are not already defined.</li>
<li><code>XXH_SIZE_OPT</code> == 2: xxHash tries to make itself as small as possible. Performance may cry. For example, the single shot functions just use the streaming API. </li>
</ul>

</div>
</div>
<a id="gaee35763869a969d5576e70dac1c08b8d" name="gaee35763869a969d5576e70dac1c08b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee35763869a969d5576e70dac1c08b8d">&#9670;&#160;</a></span>XXH_FORCE_ALIGN_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_FORCE_ALIGN_CHECK&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If defined to non-zero, adds a special path for aligned inputs (<a class="el" href="group___x_x_h32__family.html#ga310c01be2371883ad3bb37930626ec86" title="Calculates the 32-bit hash of input using xxHash32.">XXH32()</a> and <a class="el" href="group___x_x_h64__family.html#ga089c4003cb11acb60d3d1b439c69e336" title="Calculates the 64-bit hash of input using xxHash64.">XXH64()</a> only). </p>
<p>This is an important performance trick for architectures without decent unaligned memory access performance.</p>
<p>It checks for input alignment, and when conditions are met, uses a "fast
path" employing direct 32-bit/64-bit reads, resulting in <em>dramatically faster</em> read speed.</p>
<p>The check costs one initial branch per hash, which is generally negligible, but not zero.</p>
<p>Moreover, it's not useful to generate an additional code path if memory access uses the same instruction for both aligned and unaligned addresses (e.g. x86 and aarch64).</p>
<p>In these cases, the alignment check can be removed by setting this macro to 0. Then the code will always use unaligned memory access. Align check is automatically disabled on x86, x64, ARM64, and some ARM chips which are platforms known to offer good unaligned memory accesses performance.</p>
<p>It is also disabled by default when <a class="el" href="group__tuning.html#ga1e9850064fc149181cce7431f40a990a">XXH_SIZE_OPT</a> &gt;= 1.</p>
<p>This option does not affect XXH3 (only XXH32 and XXH64). </p>

</div>
</div>
<a id="gae980c41901d840d8909aa74d603ad4f1" name="gae980c41901d840d8909aa74d603ad4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae980c41901d840d8909aa74d603ad4f1">&#9670;&#160;</a></span>XXH_NO_INLINE_HINTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_NO_INLINE_HINTS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When non-zero, sets all functions to <code>static</code>. </p>
<p>By default, xxHash tries to force the compiler to inline almost all internal functions.</p>
<p>This can usually improve performance due to reduced jumping and improved constant folding, but significantly increases the size of the binary which might not be favorable.</p>
<p>Additionally, sometimes the forced inlining can be detrimental to performance, depending on the architecture.</p>
<p>XXH_NO_INLINE_HINTS marks all internal functions as static, giving the compiler full control on whether to inline or not.</p>
<p>When not optimizing (-O0), using <code>-fno-inline</code> with GCC or Clang, or if <a class="el" href="group__tuning.html#ga1e9850064fc149181cce7431f40a990a">XXH_SIZE_OPT</a> &gt;= 1, this will automatically be defined. </p>

</div>
</div>
<a id="gaa6d5f6ddf0a7d14b90a63cb6a9d34c26" name="gaa6d5f6ddf0a7d14b90a63cb6a9d34c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6d5f6ddf0a7d14b90a63cb6a9d34c26">&#9670;&#160;</a></span>XXH3_INLINE_SECRET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH3_INLINE_SECRET&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether to inline the XXH3 withSecret code. </p>
<p>When the secret size is known, the compiler can improve the performance of <a class="el" href="group___x_x_h3__family.html#ga870ba5470efb3befb1a70cb35dae12cd" title="64-bit variant of XXH3 with a custom &quot;secret&quot;.">XXH3_64bits_withSecret()</a> and <a class="el" href="group___x_x_h3__family.html#ga192ce854fdff8d491ec5201268007401" title="Custom secret 128-bit variant of XXH3.">XXH3_128bits_withSecret()</a>.</p>
<p>However, if the secret size is not known, it doesn't have any benefit. This happens when xxHash is compiled into a global symbol. Therefore, if <a class="el" href="group__public.html#ga5a61b869708b770ad75e3e063a2f9273">XXH_INLINE_ALL</a> is <em>not</em> defined, this will be defined to 0.</p>
<p>Additionally, this defaults to 0 on GCC 12+, which has an issue with function pointers that are <em>sometimes</em> force inline on -Og, and it is impossible to automatically detect this optimization level. </p>

</div>
</div>
<a id="gad5824529c4ad74d2d5cc05bf4868613a" name="gad5824529c4ad74d2d5cc05bf4868613a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5824529c4ad74d2d5cc05bf4868613a">&#9670;&#160;</a></span>XXH32_ENDJMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH32_ENDJMP&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to use a jump for <code>XXH32_finalize</code>. </p>
<p>For performance, <code>XXH32_finalize</code> uses multiple branches in the finalizer. This is generally preferable for performance, but depending on exact architecture, a jmp may be preferable.</p>
<p>This setting is only possibly making a difference for very small inputs. </p>

</div>
</div>
<a id="ga96f0b839b3187287c904d37c993f6d1f" name="ga96f0b839b3187287c904d37c993f6d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96f0b839b3187287c904d37c993f6d1f">&#9670;&#160;</a></span>XXH_NO_STREAM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_NO_STREAM</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the streaming API. </p>
<p>When xxHash is not inlined and the streaming functions are not used, disabling the streaming functions can improve code size significantly, especially with the <a class="el" href="group___x_x_h3__family.html">XXH3 family</a> which tends to make constant folded copies of itself. </p>

</div>
</div>
<a id="ga574ceb8ab088243cb0dc833b28320eb5" name="ga574ceb8ab088243cb0dc833b28320eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga574ceb8ab088243cb0dc833b28320eb5">&#9670;&#160;</a></span>XXH_DEBUGLEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_DEBUGLEVEL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debugging level. </p>
<p>XXH_DEBUGLEVEL is expected to be defined externally, typically via the compiler's command line options. The value must be a number. </p>

</div>
</div>
<a id="ga408fac02658eb4a81f7a1877f1ca3b3f" name="ga408fac02658eb4a81f7a1877f1ca3b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga408fac02658eb4a81f7a1877f1ca3b3f">&#9670;&#160;</a></span>XXH_CPU_LITTLE_ENDIAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_CPU_LITTLE_ENDIAN&#160;&#160;&#160;XXH_isLittleEndian()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the target is little endian. </p>
<p>Defined to 1 if the target is little endian, or 0 if it is big endian. It can be defined externally, for example on the compiler command line.</p>
<p>If it is not defined, a runtime check (which is usually constant folded) is used instead.</p>
<dl class="section note"><dt>Note</dt><dd>This is not necessarily defined to an integer constant.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>XXH_isLittleEndian() for the runtime check. </dd></dl>

</div>
</div>
<a id="gab216d0cd3d35dcfd7c6860ea296cdd86" name="gab216d0cd3d35dcfd7c6860ea296cdd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab216d0cd3d35dcfd7c6860ea296cdd86">&#9670;&#160;</a></span>XXH_VECTOR <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_VECTOR&#160;&#160;&#160;<a class="el" href="group__tuning.html#ggaba09620eec7211bfe2567531495bf151add8559df4f18bb2868e3c2bd5fa69a5e">XXH_SCALAR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overrides the vectorization implementation chosen for XXH3. </p>
<p>Can be defined to 0 to disable SIMD or any of the values mentioned in <a class="el" href="group__tuning.html#gaba09620eec7211bfe2567531495bf151">XXH_VECTOR_TYPE</a>.</p>
<p>If this is not defined, it uses predefined macros to determine the best implementation. </p>

</div>
</div>
<a id="gab216d0cd3d35dcfd7c6860ea296cdd86" name="gab216d0cd3d35dcfd7c6860ea296cdd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab216d0cd3d35dcfd7c6860ea296cdd86">&#9670;&#160;</a></span>XXH_VECTOR <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_VECTOR&#160;&#160;&#160;<a class="el" href="group__tuning.html#ggaba09620eec7211bfe2567531495bf151add8559df4f18bb2868e3c2bd5fa69a5e">XXH_SCALAR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overrides the vectorization implementation chosen for XXH3. </p>
<p>Can be defined to 0 to disable SIMD or any of the values mentioned in <a class="el" href="group__tuning.html#gaba09620eec7211bfe2567531495bf151">XXH_VECTOR_TYPE</a>.</p>
<p>If this is not defined, it uses predefined macros to determine the best implementation. </p>

</div>
</div>
<a id="ga15f2f40c9206c691f66cf260841f8ad1" name="ga15f2f40c9206c691f66cf260841f8ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15f2f40c9206c691f66cf260841f8ad1">&#9670;&#160;</a></span>XXH_ACC_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_ACC_ALIGN&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the minimum alignment for XXH3's accumulators. </p>
<p>When using SIMD, this should match the alignment required for said vector type, so, for example, 32 for AVX2.</p>
<p>Default: Auto detected. </p>

</div>
</div>
<a id="gac799ce966f18e4837f7fdc3d51917e9c" name="gac799ce966f18e4837f7fdc3d51917e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac799ce966f18e4837f7fdc3d51917e9c">&#9670;&#160;</a></span>XXH3_NEON_LANES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH3_NEON_LANES&#160;&#160;&#160;XXH_ACC_NB</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls the NEON to scalar ratio for XXH3. </p>
<p>This can be set to 2, 4, 6, or 8.</p>
<p>ARM Cortex CPUs are <em>very</em> sensitive to how their pipelines are used.</p>
<p>For example, the Cortex-A73 can dispatch 3 micro-ops per cycle, but only 2 of those can be NEON. If you are only using NEON instructions, you are only using 2/3 of the CPU bandwidth.</p>
<p>This is even more noticeable on the more advanced cores like the Cortex-A76 which can dispatch 8 micro-ops per cycle, but still only 2 NEON micro-ops at once.</p>
<p>Therefore, to make the most out of the pipeline, it is beneficial to run 6 NEON lanes and 2 scalar lanes, which is chosen by default.</p>
<p>This does not apply to Apple processors or 32-bit processors, which run better with full NEON. These will default to 8. Additionally, size-optimized builds run 8 lanes.</p>
<p>This change benefits CPUs with large micro-op buffers without negatively affecting most other CPUs:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Chipset   </th><th class="markdownTableHeadLeft">Dispatch type   </th><th class="markdownTableHeadRight">NEON only   </th><th class="markdownTableHeadRight">6:2 hybrid   </th><th class="markdownTableHeadRight">Diff.    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Snapdragon 730 (A76)   </td><td class="markdownTableBodyLeft">2 NEON/8 micro-ops   </td><td class="markdownTableBodyRight">8.8 GB/s   </td><td class="markdownTableBodyRight">10.1 GB/s   </td><td class="markdownTableBodyRight">~16%    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Snapdragon 835 (A73)   </td><td class="markdownTableBodyLeft">2 NEON/3 micro-ops   </td><td class="markdownTableBodyRight">5.1 GB/s   </td><td class="markdownTableBodyRight">5.3 GB/s   </td><td class="markdownTableBodyRight">~5%    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Marvell PXA1928 (A53)   </td><td class="markdownTableBodyLeft">In-order dual-issue   </td><td class="markdownTableBodyRight">1.9 GB/s   </td><td class="markdownTableBodyRight">1.9 GB/s   </td><td class="markdownTableBodyRight">0%    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Apple M1   </td><td class="markdownTableBodyLeft">4 NEON/8 micro-ops   </td><td class="markdownTableBodyRight">37.3 GB/s   </td><td class="markdownTableBodyRight">36.1 GB/s   </td><td class="markdownTableBodyRight">~-3%   </td></tr>
</table>
<p>It also seems to fix some bad codegen on GCC, making it almost as fast as clang.</p>
<p>When using WASM SIMD128, if this is 2 or 6, SIMDe will scalarize 2 of the lanes meaning it effectively becomes worse 4.</p>
<dl class="section see"><dt>See also</dt><dd>XXH3_accumulate_512_neon() </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaba09620eec7211bfe2567531495bf151" name="gaba09620eec7211bfe2567531495bf151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba09620eec7211bfe2567531495bf151">&#9670;&#160;</a></span>XXH_VECTOR_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__tuning.html#gaba09620eec7211bfe2567531495bf151">XXH_VECTOR_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible values for <a class="el" href="group__tuning.html#gab216d0cd3d35dcfd7c6860ea296cdd86">XXH_VECTOR</a>. </p>
<p>Note that these are actually implemented as macros.</p>
<p>If this is not defined, it is detected automatically. internal macro XXH_X86DISPATCH overrides this. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaba09620eec7211bfe2567531495bf151add8559df4f18bb2868e3c2bd5fa69a5e" name="ggaba09620eec7211bfe2567531495bf151add8559df4f18bb2868e3c2bd5fa69a5e"></a>XXH_SCALAR&#160;</td><td class="fielddoc"><p>Portable scalar version </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba09620eec7211bfe2567531495bf151a47d2060710fcee22a971c9912f902aa4" name="ggaba09620eec7211bfe2567531495bf151a47d2060710fcee22a971c9912f902aa4"></a>XXH_SSE2&#160;</td><td class="fielddoc"><p>SSE2 for Pentium 4, Opteron, all x86_64.</p>
<dl class="section note"><dt>Note</dt><dd>SSE2 is also guaranteed on Windows 10, macOS, and Android x86. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaba09620eec7211bfe2567531495bf151a96572760b51d70b97f5db1ebf0a95995" name="ggaba09620eec7211bfe2567531495bf151a96572760b51d70b97f5db1ebf0a95995"></a>XXH_AVX2&#160;</td><td class="fielddoc"><p>AVX2 for Haswell and Bulldozer </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba09620eec7211bfe2567531495bf151a38698e7f6fc187288a40dcf362006c29" name="ggaba09620eec7211bfe2567531495bf151a38698e7f6fc187288a40dcf362006c29"></a>XXH_AVX512&#160;</td><td class="fielddoc"><p>AVX512 for Skylake and Icelake </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba09620eec7211bfe2567531495bf151a2b9cfb9a77ed183f8551243bb2f490cb" name="ggaba09620eec7211bfe2567531495bf151a2b9cfb9a77ed183f8551243bb2f490cb"></a>XXH_NEON&#160;</td><td class="fielddoc"><p>NEON for most ARMv7-A, all AArch64, and WASM SIMD128 via the SIMDeverywhere polyfill provided with the Emscripten SDK. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba09620eec7211bfe2567531495bf151a62278d38bf34bac7e8f5bbe354a46449" name="ggaba09620eec7211bfe2567531495bf151a62278d38bf34bac7e8f5bbe354a46449"></a>XXH_VSX&#160;</td><td class="fielddoc"><p>VSX and ZVector for POWER8/z13 (64-bit) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba09620eec7211bfe2567531495bf151aedef83e5c7f75801acbde3ea771fe9f1" name="ggaba09620eec7211bfe2567531495bf151aedef83e5c7f75801acbde3ea771fe9f1"></a>XXH_SVE&#160;</td><td class="fielddoc"><p>SVE for some ARMv8-A and ARMv9-A </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
